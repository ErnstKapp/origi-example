"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filehub = void 0;
const ft3_lib_1 = require("ft3-lib");
const crypto_1 = require("../utils/crypto");
const logger_1 = require("../logger");
const Chunk_1 = require("../models/Chunk");
const FsFile_1 = require("../models/FsFile");
const Filechain_1 = require("./Filechain");
class Filehub {
    constructor(nodeUrl, brid) {
        this.blockchain = new ft3_lib_1.Postchain(nodeUrl).blockchain(brid);
    }
    static getChunkDataByHash(filechain, hash) {
        return filechain.getChunkDataByHash(hash.toString('hex'));
    }
    /**
     * Stores a file. Contacts the Filehub and allocates a chunk, and then persists the data in the correct filechain.
     */
    storeFile(user, file) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.executeOperation(user, (0, ft3_lib_1.op)('fs.allocate_file', user.authDescriptor.id, file.hash, file.size));
            return this.storeChunks(user, file);
        });
    }
    /**
     * Retrieves a file by its hash.
     *
     * @param passphrase optional options for retrieving file.
     */
    getFile(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const filechainLocations = yield this.getChunkLocations(hash);
                const promises = [];
                for (const chunkLocation of filechainLocations) {
                    logger_1.default.debug('Getting chunk %s from filechain: %s', chunkLocation.hash.toString('hex'), chunkLocation.location);
                    const filechain = this.initFilechainClient(chunkLocation.location, chunkLocation.brid.toString('hex'));
                    promises.push(this.getChunk(filechain, chunkLocation));
                }
                const chunkIndexes = yield Promise.all(promises);
                return new Promise((resolve) => resolve(FsFile_1.FsFile.fromChunks(chunkIndexes)));
            }
            catch (error) {
                logger_1.default.info('Error retrieving file: %O', error);
                const reject = Promise.reject(error);
                return reject;
            }
        });
    }
    transactionBuilder() {
        return this.blockchain.then((bc) => bc.transactionBuilder());
    }
    initFilechainClient(url, brid) {
        return new Filechain_1.default(url, brid);
    }
    storeChunks(user, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const allocationPromises = [];
            logger_1.default.debug('Storing nr of chunks: %d', file.numberOfChunks());
            for (let i = 0; i < file.numberOfChunks(); i++) {
                allocationPromises.push(this.allocateChunk(user, file.getChunk(i), file.hash, i));
            }
            yield Promise.all(allocationPromises);
            const filechainLocations = yield this.getChunkLocations(file.hash);
            const persistancePromises = [];
            for (const chunkLocation of filechainLocations) {
                logger_1.default.debug('Storing chunk %s in filechain: %s', chunkLocation.hash.toString('hex'), chunkLocation.location);
                const filechain = this.initFilechainClient(chunkLocation.location, chunkLocation.brid.toString('hex'));
                persistancePromises.push(this.persistChunkDataInFilechain(user, filechain, file.getChunk(chunkLocation.idx)));
            }
            yield Promise.all(persistancePromises);
        });
    }
    persistChunkDataInFilechain(user, filechain, data) {
        return filechain.storeChunkData(user, data);
    }
    getChunkLocations(hash) {
        return this.executeQuery('fs.get_chunk_locations', { file_hash: hash.toString('hex') }).then((locations) => {
            logger_1.default.debug('Got number of chunks: %d', locations.length);
            if (locations.length < 1) {
                throw new Error('Did not receive enough active & online Filechains');
            }
            return locations;
        });
    }
    getChunk(filechain, chunkHash) {
        return Filehub.getChunkDataByHash(filechain, chunkHash.hash).then((data) => new Chunk_1.ChunkIndex(Buffer.from(data, 'hex'), chunkHash.idx));
    }
    allocateChunk(user, chunk, fileHash, index) {
        const hash = (0, crypto_1.hashData)(chunk);
        const operation = new ft3_lib_1.Operation('fs.allocate_chunk', user.authDescriptor.id, fileHash, hash, chunk.length, index);
        return this.executeOperation(user, operation).catch(() => Promise.resolve());
    }
    /**
     * Executes a operation towards the Filehub.
     *
     * @param user to sign the operation.
     * @param operation to perform.
     */
    executeOperation(user, operation, addNop) {
        return this.blockchain.then((bc) => {
            const trxBuilder = bc.transactionBuilder().add(operation);
            if (addNop) {
                trxBuilder.add((0, ft3_lib_1.nop)());
            }
            logger_1.default.debug('Executing %O', operation);
            return trxBuilder.buildAndSign(user).post();
        });
    }
    /**
     * Queries the Filehub for data.
     *
     * @param query the identifier of the query.
     * @param data to provide in the query.
     */
    executeQuery(query, data) {
        return this.blockchain.then((bc) => {
            logger_1.default.debug("Executing query '%s' with data: %O", query, data);
            return bc.query(query, data);
        });
    }
}
exports.Filehub = Filehub;
