import AssetBalance from './asset-balance';
import PaymentHistoryIterator from "./payment-history/payment-history-iterator";
import PaymentHistorySyncManager from "./payment-history/payment-history-sync-manager";
import BlockchainSession from "../core/blockchain/blockchain-session";
import Blockchain from "../core/blockchain/blockchain";
import Operation from "../core/operation";
import RateLimit from './rate-limit';
import AuthDescriptorRule from "./auth-descriptor/auth-descriptor-rule";
import User from "./user";
declare enum AuthType {
    single_sig = "S",
    multi_sig = "M"
}
declare type PubKey = Buffer;
declare enum FlagsType {
    Account = "A",
    Transfer = "T"
}
interface GtvSerializable {
    toGTV(): any[];
}
declare class Flags {
    private flagsOrder;
    flags: Set<FlagsType>;
    constructor(flags: Set<FlagsType>);
    hasFlag(flag: FlagsType): boolean;
    toGTV(): FlagsType[];
}
interface AuthDescriptor extends GtvSerializable {
    id: Buffer;
    signers: PubKey[];
    rule: AuthDescriptorRule | null;
    hash(): Buffer;
}
declare class Account {
    readonly paymentHistorySyncManager: PaymentHistorySyncManager;
    readonly id_: Buffer;
    authDescriptor: AuthDescriptor[];
    assets: AssetBalance[];
    rateLimit: RateLimit;
    readonly session: BlockchainSession;
    constructor(id: Buffer, authDescriptor: AuthDescriptor[], session: BlockchainSession);
    readonly id: Buffer;
    readonly blockchain: Blockchain;
    static getByParticipantId(id: Buffer, session: BlockchainSession): Promise<Account[]>;
    static getByAuthDescriptorId(id: Buffer, session: BlockchainSession): Promise<Account[]>;
    static register(authDescriptor: AuthDescriptor, session: BlockchainSession): Promise<Account>;
    static rawRegisterTransaction(authDescriptor: AuthDescriptor, ssoAuthDescriptor: AuthDescriptor, session: BlockchainSession): Buffer;
    static rawTransactionRegister(user: User, authDescriptor: AuthDescriptor, blockchain: Blockchain): Buffer;
    static rawTransactionAddAuthDescriptor(accountId: Buffer, user: User, authDescriptor: AuthDescriptor, blockchain: Blockchain): Buffer;
    static getByIds(ids: Buffer[], session: BlockchainSession): Promise<Account[]>;
    static getById(id: Buffer, session: BlockchainSession): Promise<Account>;
    addAuthDescriptor(authDescriptor: AuthDescriptor): Promise<void>;
    isAuthDescriptorValid(id: Buffer): Promise<boolean>;
    deleteAllAuthDescriptorsExclude(authDescriptor: AuthDescriptor): Promise<void>;
    deleteAuthDescriptor(authDescriptor: AuthDescriptor): Promise<void>;
    sync(): Promise<void>;
    private syncAssets;
    private syncAuthDescriptors;
    private syncRateLimit;
    getAssetById(id: Buffer): AssetBalance;
    transferInputsToOutputs(inputs: Array<GtvSerializable>, outputs: Array<GtvSerializable>): Promise<void>;
    transfer(accountId: Buffer, assetId: Buffer, amount: number): Promise<void>;
    burnTokens(assetId: any, amount: any): Promise<void>;
    getPaymentHistory(): Promise<any[]>;
    getPaymentHistoryIterator(pageSize: any): Promise<PaymentHistoryIterator>;
    xcTransfer(destinationChainId: Buffer, destinationAccountId: Buffer, assetId: Buffer, amount: number): Promise<void>;
    xcTransferOp(destinationChainId: Buffer, destinationAccountId: Buffer, assetId: Buffer, amount: number): Operation;
}
export { PubKey, Account, AuthDescriptor, AuthType, Flags, FlagsType, GtvSerializable };
