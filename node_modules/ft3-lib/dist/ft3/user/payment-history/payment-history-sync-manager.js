"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var payment_history_1 = require("./payment-history");
var payment_history_entry_1 = require("./payment-history-entry");
var payment_operation_extractor_1 = require("../payment-operation-extractor");
var payment_history_store_memory_1 = require("./payment-history-store-memory");
var payment_history_store_null_object_1 = require("./payment-history-store-null-object");
var defaultPaymentHistoryStore = new payment_history_store_memory_1.default();
var ParamPaymentPair = /** @class */ (function () {
    function ParamPaymentPair(param, payment) {
        this.param = param;
        this.payment = payment;
    }
    return ParamPaymentPair;
}());
var PaymentHistorySyncManager = /** @class */ (function () {
    function PaymentHistorySyncManager() {
        this.paymentHistoryStore = defaultPaymentHistoryStore || new payment_history_store_null_object_1.default();
    }
    Object.defineProperty(PaymentHistorySyncManager, "defaultPaymentHistoryStore", {
        get: function () {
            return defaultPaymentHistoryStore;
        },
        set: function (store) {
            defaultPaymentHistoryStore = store;
        },
        enumerable: true,
        configurable: true
    });
    PaymentHistorySyncManager.deleteAccountPaymentHistory = function (accountId) {
        defaultPaymentHistoryStore.deletePaymentHistory(accountId);
    };
    PaymentHistorySyncManager.prototype.deleteAccountPaymentHistory = function (accountId) {
        this.paymentHistoryStore.deletePaymentHistory(accountId);
    };
    PaymentHistorySyncManager.prototype.syncAccount = function (id, blockchain) {
        return __awaiter(this, void 0, void 0, function () {
            var syncInfo, lastBlock, paymentHistory, paymentHistoryEntries;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        syncInfo = this.paymentHistoryStore.getSyncInfo(blockchain.id, id);
                        lastBlock = +syncInfo.lastBlock || -1;
                        return [4 /*yield*/, payment_history_1.default.getByAccountId(id, lastBlock, blockchain)];
                    case 1:
                        paymentHistory = _a.sent();
                        if (paymentHistory.length === 0) {
                            return [2 /*return*/];
                        }
                        paymentHistoryEntries = this.mapShortEntriesToLongEntries(paymentHistory, blockchain.id, id);
                        this.paymentHistoryStore.save(blockchain.id, id, paymentHistoryEntries);
                        syncInfo.lastBlock = this.getHighestBlock(paymentHistoryEntries, lastBlock);
                        this.paymentHistoryStore.saveSyncInfo(blockchain.id, id, syncInfo);
                        return [2 /*return*/];
                }
            });
        });
    };
    PaymentHistorySyncManager.prototype.mapShortEntriesToLongEntries = function (entries, chainId, accountId) {
        var e_1, _a;
        var entriesMap = this.groupShortEntriesByTransactionRID(entries);
        var paymentHistoryEntries = [];
        try {
            for (var _b = __values(entriesMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entries_1 = _c.value;
                paymentHistoryEntries.push(this.paymentHistoryEntriesFrom(entries_1, chainId, accountId));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return paymentHistoryEntries.flat().reverse();
    };
    PaymentHistorySyncManager.prototype.groupShortEntriesByTransactionRID = function (entries) {
        var entriesGroups = new Map();
        entries.forEach(function (entry) {
            if (entriesGroups.has(entry.transactionId)) {
                entriesGroups.get(entry.transactionId).push(entry);
            }
            else {
                entriesGroups.set(entry.transactionId, [entry]);
            }
        });
        return entriesGroups;
    };
    PaymentHistorySyncManager.prototype.paymentHistoryEntriesFrom = function (entries, chainId, accountId) {
        var e_2, _a;
        if (entries.length === 0) {
            return [];
        }
        var _b = __read(entries, 1), firstEntry = _b[0];
        // Get all the payments from the transaction which are related to the current account,
        // and then get all inputs and outputs for which current account is source or destination.
        var payments = this.getPaymentsForChainAndAccountFromRawTransaction(chainId.toString('hex'), accountId, firstEntry.transactionData);
        var inputs = payments
            .map(function (payment) {
            return payment.inputsWithChainAndAccount(chainId.toString('hex'), accountId.toString('hex'))
                .map(function (input) { return new ParamPaymentPair(input, payment); });
        })
            .flat();
        var outputs = payments
            .map(function (payment) {
            return payment.outputsWithChainAndAccount(chainId.toString('hex'), accountId.toString('hex'))
                .map(function (output) { return new ParamPaymentPair(output, payment); });
        })
            .flat();
        //TODO: investigate if this check has to be removed, because lib might me used with new FT3 contract which
        //maybe has new transfer type, which adds payment history entries, but transfer is not supported by this version
        //of the client lib and it will not be loaded, and in the and number of inputs and outputs will not match
        //number of entries, and therefore exception will be thrown.
        if ((inputs.length + outputs.length) !== entries.length) {
            throw new Error("Number of payment entries (" + entries.length + ") and number of transfer inputs and outputs (" + (inputs.length + outputs.length) + ") with address (" + accountId.toString('hex') + ") in the transaction are not the same");
        }
        var paymentHistoryEntries = [];
        var _loop_1 = function (entry) {
            if (entry.isInput) {
                var input_1 = this_1.matchPaymentHistoryEntryAndPaymentParam(entry, inputs, accountId);
                if (!input_1) {
                    throw new Error('Cannot match payment history entry to any transfer input');
                }
                inputs = inputs.filter(function (i) { return i !== input_1; });
                paymentHistoryEntries.push(this_1.getPaymentHistoryEntry(entry, input_1.payment));
            }
            else {
                var output_1 = this_1.matchPaymentHistoryEntryAndPaymentParam(entry, outputs, accountId);
                if (!output_1) {
                    throw new Error('Cannot match payment history entry to any transfer output');
                }
                outputs = outputs.filter(function (o) { return o !== output_1; });
                paymentHistoryEntries.push(this_1.getPaymentHistoryEntry(entry, output_1.payment));
            }
        };
        var this_1 = this;
        try {
            // In payment history entries returned from blockchain, there is no info about receiver for sent transfers
            // and sender for received transfers. In order to get sender/receiver info, we have to match payment history
            // entries to corresponding inputs and outputs extracted in previous step,
            // and then get sender/receiver from corresponding transfers.
            for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {
                var entry = entries_2_1.value;
                _loop_1(entry);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return)) _a.call(entries_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return paymentHistoryEntries;
    };
    PaymentHistorySyncManager.prototype.matchPaymentHistoryEntryAndPaymentParam = function (entry, params, accountId) {
        return params.find(function (param) { return (param.param.isAccountId(accountId.toString('hex')) &&
            param.param.isAssetId(entry.assetId) &&
            param.param.amount === entry.delta
        //TODO: compare entry index
        ); });
    };
    PaymentHistorySyncManager.prototype.getPaymentHistoryEntry = function (entry, payment) {
        var other = entry.isInput
            ? payment.outputsWithAsset(entry.assetId).map(function (_a) {
                var chainId = _a.chainId, accountId = _a.accountId;
                return ({ chainId: chainId, accountId: accountId });
            })
            : payment.inputsWithAsset(entry.assetId).map(function (_a) {
                var chainId = _a.chainId, accountId = _a.accountId;
                return ({ chainId: chainId, accountId: accountId });
            });
        return new payment_history_entry_1.default(entry.isInput, entry.delta, entry.asset, Buffer.from(entry.assetId, 'hex'), other, new Date(entry.timestamp), Buffer.from(entry.transactionId, 'hex'), entry.blockHeight);
    };
    PaymentHistorySyncManager.prototype.getHighestBlock = function (entries, lastBlock) {
        return entries
            .map(function (_a) {
            var blockHeight = _a.blockHeight;
            return blockHeight;
        })
            .reduce(function (x, y) { return Math.max(x, y); }, lastBlock);
    };
    PaymentHistorySyncManager.prototype.getPaymentsForChainAndAccountFromRawTransaction = function (chainId, accountId, transactionData) {
        return new payment_operation_extractor_1.default(transactionData, chainId)
            .extract()
            .filter(function (transfer) {
            return transfer.hasInputOrOutputWithChainAndAccount(chainId, accountId.toString('hex'));
        });
    };
    return PaymentHistorySyncManager;
}());
exports.default = PaymentHistorySyncManager;
//# sourceMappingURL=payment-history-sync-manager.js.map